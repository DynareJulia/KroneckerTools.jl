var documenterSearchIndex = {"docs":
[{"location":"#KroneckerTools","page":"KroneckerTools","title":"KroneckerTools","text":"","category":"section"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"KroneckerTools computes chains of Kronecker products as described in Kamenik (2005).","category":"page"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"The following computations are performed","category":"page"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"c = (I<sub>p</sub> ⊗ A ⊗ I<sub>q</sub>)*b\nc = (I<sub>p</sub> ⊗ A<sup>T</sup> ⊗ I<sub>q</sub>)*b\nc = (A ⊗ A ⊗ ... ⊗ A)*b\nd = (A<sup>T</sup> ⊗ A<sup>T</sup> ⊗ ... ⊗ A<sup>T</sup> ⊗ B)*c\nC = A * (B ⊗ B ⊗ .... ⊗ B)\nD = A * B * (C ⊗ C ⊗ .... ⊗ C)\nD = A<sup>T</sup> * B * (C ⊗ C ⊗ .... ⊗ C) \nE = AB(C ⊗ D ⊗ ... ⊗ D)","category":"page"},{"location":"#Installation","page":"KroneckerTools","title":"Installation","text":"","category":"section"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":" julia> using Pkg\n julia> Pkg.add(\"KroneckerTools\")","category":"page"},{"location":"#Algorithms","page":"KroneckerTools","title":"Algorithms","text":"","category":"section"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"We exploit the following property of the Kronecker product: vec(A * B * C) = (C<sup>T</sup> ⊗ A) * vec(B), so as never to form the matrix corresponding to the Kronecker product and whenever possible use matrix product instead. ","category":"page"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"Let A, a m * n matrix, B, a matrix whose size depends on the context, and b = vec(B). It follows that","category":"page"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"c = (I<sub>p</sub> ⊗ A) * b = vec(A * B), where B is a  n * p matrix.\nc = (A ⊗ I<sub>q</sub>) * b = vec(B * A<sup>T</sup>), where B is a q * m matrix\nc = (I<sub>p</sub> ⊗ A ⊗ I<sub>q</sub>) * b is computed in p blocks","category":"page"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"c<sub>i</sub> = vec(B<sub>i</sub> * A<sup>T</sup>),  i = 1, ..., p where B<sub>i</sub> is the i<sup>th</sup> block of q * n elements of vector b","category":"page"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"A chain of Kronecker products, (A<sub>1</sub> ⊗ A<sub>2</sub> ⊗ ... ⊗     A<sub>n</sub>) * b can be written as      (A<sub>1</sub> ⊗ I<sub>p<sub>1</sub></sub>)*     (I<sub>p<sub>2</sub></sub> ⊗ A<sub>2</sub> ⊗ I<sub>p<sub>2</sub></sub>)* ... *         (I<sub>p<sub>n</sub></sub> ⊗ A<sub>n</sub>)b where b is a vector and p<sub>1></sub>, p<sub>2</sub>, ..., p<sub>n</sub>, q<sub>1</sub>, q<sub>2</sub>, ...,q<sub>n</sub> are such as making each group in brackets conformable.      ","category":"page"},{"location":"#References","page":"KroneckerTools","title":"References","text":"","category":"section"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"O. Kamenik (2005), \"Solving SDGE models: A new algorithm for the Sylvester   equation\", <i>Computational Economics 25</i>, 167–187.","category":"page"},{"location":"#Methods","page":"KroneckerTools","title":"Methods","text":"","category":"section"},{"location":"","page":"KroneckerTools","title":"KroneckerTools","text":"Modules = [KroneckerTools]","category":"page"},{"location":"#KroneckerTools.a_mul_b_kron_c!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, Int64, AbstractVector, AbstractVector}","page":"KroneckerTools","title":"KroneckerTools.a_mul_b_kron_c!","text":"a_mul_b_kron_c!(d::AbstractVecOrMat, a::AbstractVecOrMat, b::AbstractMatrix, c::AbstractMatrix, order::Int64)\n\nPerforms aB(c ⊗ c ⊗ ... ⊗ c). The solution is returned in matrix or vector d. order indicates the number of occurences of c. c must be a square matrix\n\nWe use vec(ab(c ⊗ c ⊗ ... ⊗ c)) = (c' ⊗ c' ⊗ ... ⊗ c' ⊗ a)vec(b)\n\n\n\n\n\n","category":"method"},{"location":"#KroneckerTools.a_mul_b_kron_c_d!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, Int64, AbstractVector, AbstractVector}","page":"KroneckerTools","title":"KroneckerTools.a_mul_b_kron_c_d!","text":"a_mul_b_kron_c_d!(d::AbstractVecOrMat, a::AbstractVecOrMat, b::AbstractMatrix, c::AbstractMatrix, order::Int64)\n\nPerforms e = ab(c ⊗ d ⊗ ... ⊗ d). The solution is returned in matrix or vector e order indicates the number of occurences of d plus 1. c and d must be square matrices\n\nWe use vec(ab(c ⊗ d ⊗ ... ⊗ d)) = (c' ⊗ d' ⊗ ... ⊗ d' ⊗ a)vec(b)\n\n\n\n\n\n","category":"method"},{"location":"#KroneckerTools.a_mul_kron_b!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Int64, AbstractVector, AbstractVector}","page":"KroneckerTools","title":"KroneckerTools.a_mul_kron_b!","text":"a_mul_kron_b!(c::AbstractVector, a::AbstractVecOrMat, b::AbstractMatrix, order::Int64)\n\nPerforms a*(b ⊗ b ⊗ ... ⊗ b). The solution is returned in matrix c. order indicates the number of occurences of b\n\nWe use vec(a*(b ⊗ b ⊗ ... ⊗ b)) = (b' ⊗ b' ⊗ ... ⊗ b' ⊗ I)vec(a)\n\n\n\n\n\n","category":"method"},{"location":"#KroneckerTools.kron_at_kron_b_mul_c!-Tuple{AbstractMatrix, Int64, AbstractMatrix, AbstractVector, AbstractVector}","page":"KroneckerTools","title":"KroneckerTools.kron_at_kron_b_mul_c!","text":"function kron_at_kron_b_mul_c!(a::AbstractMatrix, order::Int64, b::AbstractMatrix, c::AbstractVector, work::AbstractVector)\n\nupdates c  with (a^T ⊗ a^T ⊗ ... ⊗ a^T ⊗ b)c using c and work as work vectors\n\n\n\n\n\n","category":"method"},{"location":"#KroneckerTools.kron_at_kron_b_mul_c!-Tuple{AbstractMatrix, Int64, AbstractMatrix, AbstractVector, Int64, AbstractVector}","page":"KroneckerTools","title":"KroneckerTools.kron_at_kron_b_mul_c!","text":"function kron_at_kron_b_mul_c!(a::AbstractMatrix, order::Int64, b::AbstractMatrix, c::AbstractVector, offset_c::Int64, work::AbstractVector)\n\nupdates c at offset_c with (a^T ⊗ a^T ⊗ ... ⊗ a^T ⊗ b)c using c and work as work vectors\n\n\n\n\n\n","category":"method"},{"location":"#KroneckerTools.kron_at_kron_b_mul_c!-Tuple{AbstractVector, AbstractMatrix, Int64, AbstractMatrix, AbstractVector, AbstractVector, AbstractVector}","page":"KroneckerTools","title":"KroneckerTools.kron_at_kron_b_mul_c!","text":"function kron_at_kron_b_mul_c!(d::AbstractVector, a::AbstractMatrix, order::Int64, b::AbstractMatrix, c::AbstractVector, work1::AbstractVector, work2::AbstractVector)\n\ncomputes d = (a^T ⊗ a^T ⊗ ... ⊗ a^T ⊗ b)c using work vectors work1 and work2\n\n\n\n\n\n","category":"method"},{"location":"#KroneckerTools.kron_at_kron_b_mul_c!-Tuple{AbstractVector, Int64, AbstractMatrix, Int64, AbstractMatrix, AbstractVector, Int64, AbstractVector, AbstractVector, Int64}","page":"KroneckerTools","title":"KroneckerTools.kron_at_kron_b_mul_c!","text":"function kron_at_kron_b_mul_c!(d::AbstractVector, offset_d::Int64, a::AbstractMatrix, order::Int64, b::AbstractMatrix, c::AbstractVector, offset_c::Int64, work1::AbstractVector, work2::AbstractVector, offset_w::Int64)\n\ncomputes d = (a^T ⊗ a^T ⊗ ... ⊗ a^T ⊗ b)c using data from c at offsetc and work vectors work1 and work2 at offsetw\n\n\n\n\n\n","category":"method"},{"location":"#KroneckerTools.kron_mul_elem!-Tuple{AbstractVector, Int64, AbstractMatrix, AbstractVector, Int64, Int64, Int64}","page":"KroneckerTools","title":"KroneckerTools.kron_mul_elem!","text":"kron_mul_elem!(p::Int64, q::Int64, m::Int64, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\n\nPerforms (Ip ⊗ a ⊗ Iq) b, where m,n = size(a). The result is stored in c.\n\n\n\n\n\n","category":"method"},{"location":"#KroneckerTools.kron_mul_elem_t!-Tuple{AbstractVector, Int64, AbstractMatrix, AbstractVector, Int64, Int64, Int64}","page":"KroneckerTools","title":"KroneckerTools.kron_mul_elem_t!","text":"kron_mul_elem_t!(p::Int64, q::Int64, m::Int64, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\n\nPerforms (Ip ⊗ a' ⊗ Iq) b, where m,n = size(a). The result is stored in c.\n\n\n\n\n\n","category":"method"}]
}
